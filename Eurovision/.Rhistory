pieces <- c(pieces, dcmp(i, mu1, nu1) * dcmp(x-i, mu2, nu2))
}
sum(pieces)
}
################################################
## Simulation of CMP
################################################
mu1 <- 1.5
mu2 <- 0.5
mutot <- mu1+mu2
nu <- 1.3
x <- 0:max(10,2*(mu1+mu2),2*mutot)
# Compute the distribution of the sum exactly
y.sumcmp <- c()
for (xi in x) {
y.sumcmp <- c(y.sumcmp, dsumcmp(xi, mu1, nu, mu2, nu))
}
# Do a naive sum of mu's
y.cmp.naive <- dcmp(x, mutot, nu)
barplot(rbind(y.cmp.naive, y.sumcmp), names.arg=x, legend.text=c("CMP(mu1+mu2)", "CMP(mu1)+CMP(mu2)"), beside=TRUE)
#######################################################
## Quasi-binomial weighting factor in convolution
#######################################################
# Function to compute weights which distort the sum of two CMP random variables
# Relative to the CMP random variable with the sum of their mu parameters
# p = mu1/(mu1+mu2)
# nu = value from CMP distributions being added
# y = value of the sum for which this weight is applied
qbs.weight <- function(y, p, nu) {
sum(dbinom(0:y, size=y, prob=p) ^ nu)
}
p <- 1/12
nu <- 1.2
y <- 0:100
weights <- c()
for (yi in y) {
weights <- c(weights, qbs.weight(yi, p, nu))
}
barplot(weights, names.arg=y)
###########################################
## CMP Functions
###########################################
logsumexp <- function(x, y) {
pmax(x,y) + log1p(exp(-abs(x-y)))
}
cmp.logZ <- function(mu, nu) {
# Prepare some constants
log_mu <- log(mu)
logeps <- log(1e-16)
# Get through the first two terms
logZ <- log1p(exp(nu * log_mu))
logterm <- nu * log_mu
i <- 1
# Go until relative tolerance reached
while (any(logterm - logZ >= logeps)) {
i <- i + 1
logterm <- nu * (i * log(mu) - lfactorial(i))
logZ <- logsumexp(logZ, logterm)
}
# Return the constant
logZ
}
cmp.Z <- function(mu, nu) {
exp(cmp.logZ(mu, nu))
}
dcmp <- function(x, mu, nu) {
exp(nu * (x * log(mu) - lfactorial(x)) - cmp.logZ(mu, nu))
}
dsumcmp <- function(x, mu1, nu1, mu2, nu2) {
pieces <- c()
for (i in 0:x) {
pieces <- c(pieces, dcmp(i, mu1, nu1) * dcmp(x-i, mu2, nu2))
}
sum(pieces)
}
################################################
## Simulation of CMP
################################################
mu1 <- 1.5
mu2 <- 0.5
mutot <- mu1+mu2
nu <- 1.3
x <- 0:max(10,2*(mu1+mu2),2*mutot)
# Compute the distribution of the sum exactly
y.sumcmp <- c()
for (xi in x) {
y.sumcmp <- c(y.sumcmp, dsumcmp(xi, mu1, nu, mu2, nu))
}
# Do a naive sum of mu's
y.cmp.naive <- dcmp(x, mutot, nu)
barplot(rbind(y.cmp.naive, y.sumcmp), names.arg=x, legend.text=c("CMP(mu1+mu2)", "CMP(mu1)+CMP(mu2)"), beside=TRUE)
#######################################################
## Quasi-binomial weighting factor in convolution
#######################################################
# Function to compute weights which distort the sum of two CMP random variables
# Relative to the CMP random variable with the sum of their mu parameters
# p = mu1/(mu1+mu2)
# nu = value from CMP distributions being added
# y = value of the sum for which this weight is applied
qbs.weight <- function(y, p, nu) {
sum(dbinom(0:y, size=y, prob=p) ^ nu)
}
p <- 1/12
nu <- 1.2
y <- 0:1000
weights <- c()
for (yi in y) {
weights <- c(weights, qbs.weight(yi, p, nu))
}
barplot(weights, names.arg=y)
p <- 1/12
nu <- 1.2
y <- 0:100
weights <- c()
for (yi in y) {
weights <- c(weights, qbs.weight(yi, p, nu))
}
barplot(weights, names.arg=y)
###########################################
## CMP Functions
###########################################
logsumexp <- function(x, y) {
pmax(x,y) + log1p(exp(-abs(x-y)))
}
cmp.logZ <- function(mu, nu) {
# Prepare some constants
log_mu <- log(mu)
logeps <- log(1e-16)
# Get through the first two terms
logZ <- log1p(exp(nu * log_mu))
logterm <- nu * log_mu
i <- 1
# Go until relative tolerance reached
while (any(logterm - logZ >= logeps)) {
i <- i + 1
logterm <- nu * (i * log(mu) - lfactorial(i))
logZ <- logsumexp(logZ, logterm)
}
# Return the constant
logZ
}
cmp.Z <- function(mu, nu) {
exp(cmp.logZ(mu, nu))
}
dcmp <- function(x, mu, nu) {
exp(nu * (x * log(mu) - lfactorial(x)) - cmp.logZ(mu, nu))
}
dsumcmp <- function(x, mu1, nu1, mu2, nu2) {
pieces <- c()
for (i in 0:x) {
pieces <- c(pieces, dcmp(i, mu1, nu1) * dcmp(x-i, mu2, nu2))
}
sum(pieces)
}
################################################
## Simulation of CMP
################################################
mu1 <- 1.5
mu2 <- 0.5
mutot <- mu1+mu2
nu <- 1.3
x <- 0:max(10,2*(mu1+mu2),2*mutot)
# Compute the distribution of the sum exactly
y.sumcmp <- c()
for (xi in x) {
y.sumcmp <- c(y.sumcmp, dsumcmp(xi, mu1, nu, mu2, nu))
}
# Do a naive sum of mu's
y.cmp.naive <- dcmp(x, mutot, nu)
barplot(rbind(y.cmp.naive, y.sumcmp), names.arg=x, legend.text=c("CMP(mu1+mu2)", "CMP(mu1)+CMP(mu2)"), beside=TRUE)
#######################################################
## Quasi-binomial weighting factor in convolution
#######################################################
# Function to compute weights which distort the sum of two CMP random variables
# Relative to the CMP random variable with the sum of their mu parameters
# p = mu1/(mu1+mu2)
# nu = value from CMP distributions being added
# y = value of the sum for which this weight is applied
qbs.weight <- function(y, p, nu) {
sum(dbinom(0:y, size=y, prob=p) ^ nu)
}
p <- 1/12
nu <- 1.2
y <- 0:120
weights <- c()
for (yi in y) {
weights <- c(weights, qbs.weight(yi, p, nu))
}
barplot(weights, names.arg=y)
# Function to compute weights which distort the sum of two CMP random variables
# Relative to the CMP random variable with the sum of their mu parameters
# p = mu1/(mu1+mu2)
# nu = value from CMP distributions being added
# y = value of the sum for which this weight is applied
qbs.weight <- function(y, p, nu) {
sum(dbinom(0:y, size=y, prob=p) ^ nu)
}
p <- 1/12
nu <- 5
y <- 0:120
weights <- c()
for (yi in y) {
weights <- c(weights, qbs.weight(yi, p, nu))
}
barplot(weights, names.arg=y)
p <- 1/12
nu <- 0.7
y <- 0:120
weights <- c()
for (yi in y) {
weights <- c(weights, qbs.weight(yi, p, nu))
}
barplot(weights, names.arg=y)
# Function to compute weights which distort the sum of two CMP random variables
# Relative to the CMP random variable with the sum of their mu parameters
# p = mu1/(mu1+mu2)
# nu = value from CMP distributions being added
# y = value of the sum for which this weight is applied
qbs.weight <- function(y, p, nu) {
sum(dbinom(0:y, size=y, prob=p) ^ nu)
}
p <- 1/12
nu <- 0.1
y <- 0:120
weights <- c()
for (yi in y) {
weights <- c(weights, qbs.weight(yi, p, nu))
}
barplot(weights, names.arg=y)
install.packages("remotes"0)
install.packages("remotes")
library(remotes)
install_github("msadinle/BRL")
setwd("Documents/School/Research/Latentspace/Working/Eurovision/")
ls
dir()
read.csv("votes-ranks.csv")
read.csv("votes-ranks.csv", row.names=TRUE, col.names=TRUE)
read.csv("votes-ranks.csv", row.names=1)
Y <- read.csv("votes-ranks.csv", row.names=1)
X.gender <- read.csv("covariate-gender.csv", row.names=1)
X.gender
# Which countries are we restricting the analysis to?
countries.in.final <- row.names(Xc.gender)[Xc.gender != "#N/A"]
# Code to do that data analysis on the Eurovision data
library(amen)
# Read in all the csv files with response and covariates
Y <- read.csv("votes-ranks.csv", row.names=1)
Xc.gender <- read.csv("covariate-gender.csv", row.names=1)
Xd.lang <- read.csv("covariate-language.csv", row.names=1)
# Which countries are we restricting the analysis to?
countries.in.final <- row.names(Xc.gender)[Xc.gender != "#N/A"]
countries.in.final
Xc.gender[,"Gender"]
Xc.gender[,"Female"]
# Code to do that data analysis on the Eurovision data
library(amen)
# Read in all the csv files with response and covariates
Y <- read.csv("votes-ranks.csv", row.names=1)
Xc.gender <- read.csv("covariate-gender.csv", row.names=1)
Xd.lang <- read.csv("covariate-language.csv", row.names=1)
# Which countries are we restricting the analysis to?
countries.in.final <- row.names(Xc.gender)[Xc.gender[,"Female"] != "#N/A"]
countries.in.final
?ame
# Code to do that data analysis on the Eurovision data
library(amen)
# Read in all the csv files with response and covariates
Y <- read.csv("votes-ranks.csv", row.names=1)
Xc.gender <- read.csv("covariate-gender.csv", row.names=1)
Xd.lang <- read.csv("covariate-language.csv", row.names=1)
# Which countries are we restricting the analysis to?
countries.in.final <- row.names(Xc.gender)[Xc.gender[,"Female"] != "#N/A"]
res <- ame(Y[countries.in.final,countries.in.final], Xcol=Xc.gender[countries.in.final,], Xdyad=Xd.lang[countries.in.final,countries.in.final], model="frn")
# Code to do that data analysis on the Eurovision data
library(amen)
# Read in all the csv files with response and covariates
Y <- as.matrix(read.csv("votes-ranks.csv", row.names=1))
Xc.gender <- read.csv("covariate-gender.csv", row.names=1)
Xd.lang <- read.csv("covariate-language.csv", row.names=1)
# Which countries are we restricting the analysis to?
countries.in.final <- row.names(Xc.gender)[Xc.gender[,"Female"] != "#N/A"]
res <- ame(Y[countries.in.final,countries.in.final], Xcol=Xc.gender[countries.in.final,], Xdyad=Xd.lang[countries.in.final,countries.in.final], model="frn")
Y
Y[countries.in.final]
Y[countries.in.final, countries.in.final]
# Code to do that data analysis on the Eurovision data
library(amen)
# Read in all the csv files with response and covariates
Y <- read.csv("votes-ranks.csv", row.names=1)
Xc.gender <- read.csv("covariate-gender.csv", row.names=1)
Xd.lang <- read.csv("covariate-language.csv", row.names=1)
# Which countries are we restricting the analysis to?
countries.in.final <- row.names(Xc.gender)[Xc.gender[,"Female"] != "#N/A"]
res <- ame(Y[countries.in.final,countries.in.final], Xcol=Xc.gender[countries.in.final,], Xdyad=Xd.lang[countries.in.final,countries.in.final], model="frn")
Y
Y[countries.in.final,]
Y[countries.in.final,countries.in.final]
Y[countries.in.final]
colnames(Y)
countries.in.final
# Code to do that data analysis on the Eurovision data
library(amen)
# Read in all the csv files with response and covariates
Y <- read.csv("votes-ranks.csv", row.names=1)
Xc.gender <- read.csv("covariate-gender.csv", row.names=1)
Xd.lang <- read.csv("covariate-language.csv", row.names=1)
# Which countries are we restricting the analysis to?
countries.in.final <- row.names(Xc.gender)[Xc.gender[,"Female"] != "#N/A"]
res <- ame(Y[countries.in.final,countries.in.final], Xcol=Xc.gender[countries.in.final,], Xdyad=Xd.lang[countries.in.final,countries.in.final], model="frn")
# Code to do that data analysis on the Eurovision data
library(amen)
# Read in all the csv files with response and covariates
Y <- read.csv("votes-ranks.csv", row.names=1)
Xc.gender <- read.csv("covariate-gender.csv", row.names=1)
Xd.lang <- read.csv("covariate-language.csv", row.names=1)
# Which countries are we restricting the analysis to?
countries.in.final <- row.names(Xc.gender)[Xc.gender[,"Female"] != "#N/A"]
res <- ame(Y[countries.in.final,countries.in.final], Xcol=Xc.gender[countries.in.final,], Xdyad=Xd.lang[countries.in.final,countries.in.final], model="frn")
Y[countries.in.final,countries.in.final]
as.matrix(Y[countries.in.final,countries.in.final])
as.array(Xd.lang[countries.in.final,countries.in.final])
as.array(as.matrix(Xd.lang[countries.in.final,countries.in.final]))
dim(as.array(as.matrix(Xd.lang[countries.in.final,countries.in.final])))
?as.array
dim(as.array(as.matrix(Xd.lang[countries.in.final,countries.in.final]), dim=c(length(countries.in.final), length(countries.in.final), 1)))
is.array(as.array(as.matrix(Xd.lang[countries.in.final,countries.in.final]), dim=c(length(countries.in.final), length(countries.in.final), 1)))
# Code to do that data analysis on the Eurovision data
library(amen)
# Read in all the csv files with response and covariates
Y <- read.csv("votes-ranks.csv", row.names=1)
Xc.gender <- read.csv("covariate-gender.csv", row.names=1)
Xd.lang <- read.csv("covariate-language.csv", row.names=1)
# Which countries are we restricting the analysis to?
countries.in.final <- row.names(Xc.gender)[Xc.gender[,"Female"] != "#N/A"]
res <- ame(Y=as.matrix(Y[countries.in.final,countries.in.final]),
Xcol=as.matrix(Xc.gender[countries.in.final,]),
Xdyad=as.array(as.matrix(Xd.lang[countries.in.final,countries.in.final])),
model="frn")
Xd.lang["Greece", "Lithuania"]
Xd.lang["Greece", "Lithuania"] == 0
# Code to do that data analysis on the Eurovision data
library(amen)
# Read in all the csv files with response and covariates
Y <- read.csv("votes-ranks.csv", row.names=1)
Xc.gender <- read.csv("covariate-gender.csv", row.names=1)
Xd.lang <- read.csv("covariate-language.csv", row.names=1)
# Which countries are we restricting the analysis to?
countries.in.final <- row.names(Xc.gender)[Xc.gender[,"Female"] != "#N/A"]
res <- ame(Y=as.matrix(Y[countries.in.final,countries.in.final]),
Xcol=as.matrix(Xc.gender[countries.in.final,]),
Xdyad=as.array(as.matrix(Xd.lang[countries.in.final,countries.in.final])),
model="frn")
# Code to do that data analysis on the Eurovision data
library(amen)
# Read in all the csv files with response and covariates
Y <- read.csv("votes-ranks.csv", row.names=1)
Xc.gender <- read.csv("covariate-gender.csv", row.names=1)
Xd.lang <- read.csv("covariate-language.csv", row.names=1)
# Which countries are we restricting the analysis to?
countries.in.final <- row.names(Xc.gender)[Xc.gender[,"Female"] != "#N/A"]
res <- ame(Y=as.matrix(Y[countries.in.final,countries.in.final]),
Xcol=as.matrix(Xc.gender[countries.in.final,]),
model="frn")
Xc.gender[countries.in.final,countries.in.final]
Xc.gender[countries.in.final,]
type(Xc.gender[countries.in.final,])
Xc.gender[countries.in.final,]
as.integer(Xc.gender[countries.in.final,])
as.integer(as.matrix(Xc.gender[countries.in.final,]))
# Code to do that data analysis on the Eurovision data
library(amen)
# Read in all the csv files with response and covariates
Y <- read.csv("votes-ranks.csv", row.names=1)
Xc.gender <- read.csv("covariate-gender.csv", row.names=1)
Xd.lang <- read.csv("covariate-language.csv", row.names=1)
# Which countries are we restricting the analysis to?
countries.in.final <- row.names(Xc.gender)[Xc.gender[,"Female"] != "#N/A"]
res <- ame(Y=as.matrix(Y[countries.in.final,countries.in.final]),
Xcol=as.matrix(Xc.gender[countries.in.final,]),
Xdyad=as.array(as.matrix(Xd.lang[countries.in.final,countries.in.final])),
model="frn")
# Code to do that data analysis on the Eurovision data
library(amen)
# Read in all the csv files with response and covariates
Y <- read.csv("votes-ranks.csv", row.names=1)
Xc.gender <- read.csv("covariate-gender.csv", row.names=1)
Xd.lang <- read.csv("covariate-language.csv", row.names=1)
# Which countries are we restricting the analysis to?
countries.in.final <- row.names(Xc.gender)[Xc.gender[,"Female"] != "#N/A"]
res <- ame(Y=as.matrix(Y[countries.in.final,countries.in.final]),
#Xcol=as.matrix(Xc.gender[countries.in.final,]),
#Xdyad=as.array(as.matrix(Xd.lang[countries.in.final,countries.in.final])),
model="frn")
res
res$BETA
# Code to do that data analysis on the Eurovision data
library(amen)
# Read in all the csv files with response and covariates
Y <- read.csv("votes-ranks.csv", row.names=1)
Xc.gender <- read.csv("covariate-gender.csv", row.names=1)
Xd.lang <- read.csv("covariate-language.csv", row.names=1)
# Which countries are we restricting the analysis to?
countries.in.final <- row.names(Xc.gender)[Xc.gender[,"Female"] != "#N/A"]
res <- ame(Y=as.matrix(Y[countries.in.final,countries.in.final]),
#Xcol=as.matrix(Xc.gender[countries.in.final,]),
Xdyad=as.array(as.matrix(Xd.lang[countries.in.final,countries.in.final])),
model="frn")
res$BETA
colMeans(res$BETA)
# Code to do that data analysis on the Eurovision data
library(amen)
# Read in all the csv files with response and covariates
Y <- read.csv("votes-ranks.csv", row.names=1)
Xc.gender <- read.csv("covariate-gender.csv", row.names=1)
Xd.lang <- read.csv("covariate-language.csv", row.names=1)
# Which countries are we restricting the analysis to?
countries.in.final <- row.names(Xc.gender)[Xc.gender[,"Female"] != "#N/A"]
res <- ame(Y=as.matrix(Y[countries.in.final,countries.in.final]),
Xcol=as.matrix(Xc.gender[countries.in.final,]),
Xdyad=as.array(as.matrix(Xd.lang[countries.in.final,countries.in.final])),
model="frn")
Xc.gender[countries.in.final,]
as.matrix(Xc.gender[countries.in.final,])
data.matrix(Xc.gender[countries.in.final,])
Xc.gender <- read.csv("covariate-gender.csv", row.names=1, stringsAsFactors=FALSE)
data.matrix(Xc.gender[countries.in.final,])
# Code to do that data analysis on the Eurovision data
library(amen)
# Read in all the csv files with response and covariates
Y <- read.csv("votes-ranks.csv", row.names=1)
Xc.gender <- read.csv("covariate-gender.csv", row.names=1, stringsAsFactors=FALSE)
Xd.lang <- read.csv("covariate-language.csv", row.names=1)
# Which countries are we restricting the analysis to?
countries.in.final <- row.names(Xc.gender)[Xc.gender[,"Female"] != "#N/A"]
res <- ame(Y=as.matrix(Y[countries.in.final,countries.in.final]),
Xcol=data.matrix(Xc.gender[countries.in.final,]),
Xdyad=as.array(as.matrix(Xd.lang[countries.in.final,countries.in.final])),
model="frn")
res$BETA
colnames(res$BETA)
colMeans(res$BETA)
quantile(res$BETA)
quantile(res$BETA[,"Female.col"])
quantile(res$BETA[,"Female.col"], probs=c(.025,.975))
quantile(res$BETA[,"Group.col"], probs=c(.025,.975))
quantile(res$BETA[,"Interaction.col"], probs=c(.025,.975))
quantile(res$BETA[,".dyad"], probs=c(.025,.975))
# Code to do that data analysis on the Eurovision data
library(amenhs)
# Read in all the csv files with response and covariates
Y <- read.csv("votes-ranks.csv", row.names=1)
Xc.gender <- read.csv("covariate-gender.csv", row.names=1, stringsAsFactors=FALSE)
Xd.lang <- read.csv("covariate-language.csv", row.names=1)
# Which countries are we restricting the analysis to?
countries.in.final <- row.names(Xc.gender)[Xc.gender[,"Female"] != "#N/A"]
res <- amenhs::ame(Y=as.matrix(Y[countries.in.final,countries.in.final]),
Xcol=data.matrix(Xc.gender[countries.in.final,]),
Xdyad=as.array(as.matrix(Xd.lang[countries.in.final,countries.in.final])),
model="frn")
res.hc <- amenhs::ame(Y=as.matrix(Y[countries.in.final,countries.in.final]),
Xcol=data.matrix(Xc.gender[countries.in.final,]),
Xdyad=as.array(as.matrix(Xd.lang[countries.in.final,countries.in.final])),
model="frn", halfcauchy=TRUE)
res.proj <- amenhs::ame(Y=as.matrix(Y[countries.in.final,countries.in.final]),
Xcol=data.matrix(Xc.gender[countries.in.final,]),
Xdyad=as.array(as.matrix(Xd.lang[countries.in.final,countries.in.final])),
model="frn", halfcauchy=TRUE, project=TRUE)
# Code to do that data analysis on the Eurovision data
library(amenhs)
# Read in all the csv files with response and covariates
Y <- read.csv("votes-ranks.csv", row.names=1)
Xc.gender <- read.csv("covariate-gender.csv", row.names=1, stringsAsFactors=FALSE)
Xd.lang <- read.csv("covariate-language.csv", row.names=1)
# Which countries are we restricting the analysis to?
countries.in.final <- row.names(Xc.gender)[Xc.gender[,"Female"] != "#N/A"]
res <- amenhs::ame(Y=as.matrix(Y[countries.in.final,countries.in.final]),
Xcol=data.matrix(Xc.gender[countries.in.final,]),
Xdyad=as.array(as.matrix(Xd.lang[countries.in.final,countries.in.final])),
family="frn")
res.hc <- amenhs::ame(Y=as.matrix(Y[countries.in.final,countries.in.final]),
Xcol=data.matrix(Xc.gender[countries.in.final,]),
Xdyad=as.array(as.matrix(Xd.lang[countries.in.final,countries.in.final])),
family="frn", halfcauchy=TRUE)
res.proj <- amenhs::ame(Y=as.matrix(Y[countries.in.final,countries.in.final]),
Xcol=data.matrix(Xc.gender[countries.in.final,]),
Xdyad=as.array(as.matrix(Xd.lang[countries.in.final,countries.in.final])),
family="frn", halfcauchy=TRUE, project=TRUE)
colMeans(res$BETA)
colMeans(res.hc$BETA)
colMeans(res.proj$BETA)
apply(res$BETA, MARGIN=1, FUN=mean)
apply(res$BETA, MARGIN=2, FUN=mean)
apply(res$BETA, MARGIN=2, FUN=quantile)
apply(res$BETA, MARGIN=2, FUN=quantile, probs=c(0.025, 0.25, 0.5, 0.75, 0.975))
apply(res.proj$BETA, MARGIN=2, FUN=quantile, probs=c(0.025, 0.25, 0.5, 0.75, 0.975))
# Summarize results (BETA)
colMeans(res$BETA)
apply(res$BETA, MARGIN=2, FUN=quantile, probs=c(0.025, 0.25, 0.5, 0.75, 0.975))
colMeans(res.hc$BETA)
apply(res.hc$BETA, MARGIN=2, FUN=quantile, probs=c(0.025, 0.25, 0.5, 0.75, 0.975))
colMeans(res.proj$BETA)
apply(res.proj$BETA, MARGIN=2, FUN=quantile, probs=c(0.025, 0.25, 0.5, 0.75, 0.975))
res.hc$VC
hist(res.hc$VC[,1])
colMeans(res$BETA)
apply(res$BETA, MARGIN=2, FUN=quantile, probs=c(0.025, 0.25, 0.5, 0.75, 0.975))
colMeans(res.hc$BETA)
apply(res.hc$BETA, MARGIN=2, FUN=quantile, probs=c(0.025, 0.25, 0.5, 0.75, 0.975))
colMeans(res.proj$BETA)
apply(res.proj$BETA, MARGIN=2, FUN=quantile, probs=c(0.025, 0.25, 0.5, 0.75, 0.975))
length(countries.in.final)
